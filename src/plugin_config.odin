package wayu

import "core:fmt"
import "core:os"
import "core:strings"
import "core:time"

// Generate plugins.{zsh,bash} loader file
generate_plugins_file :: proc(shell: ShellType) -> bool {
	ext := get_shell_extension(shell)
	plugins_file := fmt.aprintf("%s/plugins.%s", WAYU_CONFIG, ext)
	defer delete(plugins_file)

	// Read current configuration (JSON format with dependencies support)
	config, ok := read_plugin_config_json()
	if !ok {
		// Fall back to empty config if read fails
		config.version = "1.0"
		config.last_updated = get_iso8601_timestamp()
		config.plugins = make([dynamic]PluginMetadata)
	}
	defer cleanup_plugin_config_json(&config)

	// Build plugin loader script
	sb := strings.builder_make()
	defer strings.builder_destroy(&sb)

	shebang := get_shebang(shell)
	strings.write_string(&sb, shebang)
	strings.write_string(&sb, "\n# Auto-generated by wayu - DO NOT EDIT\n")

	// Add timestamp
	now := time.now()
	year, month, day := time.date(now)
	hour, minute, second := time.clock(now)
	timestamp := fmt.aprintf("# Last updated: %d-%02d-%02d %02d:%02d:%02d\n\n",
		year, month, day, hour, minute, second)
	defer delete(timestamp)
	strings.write_string(&sb, timestamp)

	strings.write_string(&sb, "# Load enabled plugins\n\n")

	// Phase 5: Resolve load order with priority
	load_order, order_ok := resolve_dependencies_with_priority(&config)
	if !order_ok {
		fmt.eprintln("Error: Failed to resolve plugin load order (circular dependency)")
		return false
	}
	defer {
		for name in load_order {
			delete(name)
		}
		delete(load_order)
	}

	// Phase 6: Detect conflicts between enabled plugins
	detect_conflicts(&config)

	// Check if any conflicts were detected
	conflicts_detected := false
	for plugin in config.plugins {
		if plugin.enabled && plugin.conflicts.detected {
			conflicts_detected = true
			break
		}
	}

	// Add global conflict warning header if conflicts exist
	if conflicts_detected {
		strings.write_string(&sb, "# ⚠️  CONFLICT WARNINGS\n")
		strings.write_string(&sb, "# The following plugins have potential conflicts:\n")

		// List all conflicting plugins
		for plugin in config.plugins {
			if plugin.enabled && plugin.conflicts.detected {
				conflicts_str := strings.join(plugin.conflicts.conflicting_plugins[:], ", ")
				warning := fmt.aprintf("#   - %s conflicts with: %s\n", plugin.name, conflicts_str)
				strings.write_string(&sb, warning)
				delete(warning)
				delete(conflicts_str)
			}
		}

		strings.write_string(&sb, "# This may cause unexpected behavior. Review your plugin configuration.\n\n")
	}

	// Generate source statements for enabled plugins in priority/dependency order
	for plugin_name in load_order {
		// Find plugin metadata
		plugin_ptr, found_plugin := find_plugin_json(&config, plugin_name)
		if !found_plugin || !plugin_ptr.enabled {
			continue
		}
		plugin := plugin_ptr^

		// Skip if shell incompatible
		if plugin.shell == .ZSH && shell == .BASH {
			continue
		}
		if plugin.shell == .BASH && shell == .ZSH {
			continue
		}

		// Detect plugin entry file
		entry_file, found := detect_plugin_file(plugin.installed_path, plugin.name, shell)

		// Phase 4: Check for missing or disabled dependencies
		if len(plugin.dependencies) > 0 {
			missing := make([dynamic]string)
			disabled := make([dynamic]string)
			defer delete(missing)
			defer delete(disabled)

			for dep_name in plugin.dependencies {
				dep_plugin, dep_found := find_plugin_json(&config, dep_name)
				if !dep_found {
					append(&missing, dep_name)
				} else if !dep_plugin.enabled {
					append(&disabled, dep_name)
				}
			}

			// Add warning comments for missing dependencies
			if len(missing) > 0 {
				warning_line := fmt.aprintf("# ⚠️  WARNING: Plugin '%s' has missing dependencies:\n", plugin.name)
				strings.write_string(&sb, warning_line)
				delete(warning_line)

				for dep in missing {
					dep_line := fmt.aprintf("#   - %s (not installed)\n", dep)
					strings.write_string(&sb, dep_line)
					delete(dep_line)
				}

				missing_str := strings.join(missing[:], " ")
				install_line := fmt.aprintf("# Install with: wayu plugin add %s\n\n", missing_str)
				strings.write_string(&sb, install_line)
				delete(install_line)
				delete(missing_str)
			}

			// Add warning comments for disabled dependencies
			if len(disabled) > 0 {
				warning_line := fmt.aprintf("# ⚠️  WARNING: Plugin '%s' has disabled dependencies:\n", plugin.name)
				strings.write_string(&sb, warning_line)
				delete(warning_line)

				for dep in disabled {
					dep_line := fmt.aprintf("#   - %s (disabled)\n", dep)
					strings.write_string(&sb, dep_line)
					delete(dep_line)
				}

				disabled_str := strings.join(disabled[:], " ")
				enable_line := fmt.aprintf("# Enable with: wayu plugin enable %s\n\n", disabled_str)
				strings.write_string(&sb, enable_line)
				delete(enable_line)
				delete(disabled_str)
			}
		}

		// Phase 6: Add per-plugin conflict warning if detected
		if plugin.conflicts.detected {
			conflict_warning := fmt.aprintf("# ⚠️  WARNING: %s has conflicts\n", plugin.name)
			strings.write_string(&sb, conflict_warning)
			delete(conflict_warning)
		}

		if found {
			// Single file to source
			comment := fmt.aprintf("# %s (priority: %d)\n", plugin.name, plugin.priority)
			strings.write_string(&sb, comment)
			delete(comment)

			source_line := fmt.aprintf("if [ -f %s ]; then\n    source %s\nfi\n\n",
				entry_file, entry_file)
			strings.write_string(&sb, source_line)
			delete(source_line)
		} else {
			// Source all .{zsh,bash} files in directory
			comment := fmt.aprintf("# %s (priority: %d, all .%s files)\n", plugin.name, plugin.priority, ext)
			strings.write_string(&sb, comment)
			delete(comment)

			source_block := fmt.aprintf(
				"for f in %s/*.%s; do\n" +
				"    [ -f \"$f\" ] && source \"$f\"\n" +
				"done\n\n",
				plugin.installed_path, ext)
			strings.write_string(&sb, source_block)
			delete(source_block)
		}

		if found {
			delete(entry_file)
		}
	}

	strings.write_string(&sb, "# End of plugin loading\n")

	// Write to file
	content := strings.to_string(sb)

	if DRY_RUN {
		print_info("[DRY RUN] Would write plugins file: %s", plugins_file)
		return true
	}

	return os.write_entire_file(plugins_file, transmute([]byte)content) == nil
}

